--[[
  #####    #       #  #       #  #       #
 #     #   ##      #   #     #    #     # 
#       #  # #     #    #   #      #   #  
#       #  #  #    #     # #        # #   
#       #  #   #   #      #         # #   
#       #  #    #  #      #        #   #  
 #     #   #     # #      #       #     # 
  #####    #      ##      #      #       #
                          Made by: Biscuit
]]

Onyx Loader
Handles key authentication, then loadstrings the main script.
Host your main script somewhere with a raw URL and set MAIN_SCRIPT_URL below.
]]

-- =====================================================
-- CONFIG
-- =====================================================
local ONYX_URL = "https://onyx-backend-production-22fa.up.railway.app"
local MAIN_SCRIPT_URL   = "https://raw.githubusercontent.com/EORScopeZ/OnyxV2/refs/heads/main/OnyxV2.lua"
-- ^ Replace with your raw GitHub/Pastebin/etc URL for the main script

-- =====================================================
-- SERVICES
-- =====================================================
local Players           = game:GetService("Players")
local TweenService      = game:GetService("TweenService")
local HttpService       = game:GetService("HttpService")
local plr               = Players.LocalPlayer

-- =====================================================
-- CLEANUP
-- =====================================================
if game.CoreGui:FindFirstChild("OnyxAuth") then
game.CoreGui.OnyxAuth:Destroy()
end

-- =====================================================
-- HTTP (Xeno + other executor compatible)
-- Uses pcall on every global access so Xeno doesn't crash
-- =====================================================
local httpRequest
do
    local candidates = {
        function() return request end,
        function() return http and http.request end,
        function() return http_request end,
        function() return syn and syn.request end,
        function() return fluxus and fluxus.request end,
    }
    for _, getter in ipairs(candidates) do
        local ok, fn = pcall(getter)
        if ok and type(fn) == "function" then
            httpRequest = fn
            break
        end
    end
    if not httpRequest then
        httpRequest = function(options)
            local ok, result = pcall(function()
                return HttpService:RequestAsync(options)
            end)
            return ok and result or { Success = false, StatusCode = 0, Body = "" }
        end
    end
end

local function buildUrl(endpoint)
    return ONYX_URL:gsub("/$", "") .. "/" .. endpoint:gsub("^/", "")
end

-- =====================================================

-- =====================================================
-- HELPERS (Sends telemetry to bot)
-- =====================================================
local function GetHWID()
    local hwid = "Unknown"
    pcall(function()
        hwid = game:GetService("RbxAnalyticsService"):GetClientId()
    end)
    return hwid
end

local function GetExecutor()
    return (identifyexecutor or getexecutorname or function() return "Unknown" end)()
end

local function SendExecutionLog(authType)
    local thumbUrl = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. plr.UserId .. "&width=150&height=150&format=png"
    
    local logData = {
        username = plr.Name,
        userId   = plr.UserId,
        hwid     = GetHWID(),
        executor = GetExecutor(),
        thumbUrl = thumbUrl,
        ip       = "Captured by Server", -- The bot will see the request IP
        type     = authType or "Unknown"
    }

    pcall(function()
        httpRequest({
            Url     = buildUrl("/log-execution"),
            Method  = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body    = HttpService:JSONEncode(logData)
        })
    end)
end

-- =====================================================
-- VALIDATE (username-first: whitelist ‚Üí key fallback)
-- =====================================================

-- Round 1: sends only username -- returns whitelisted:true if they're on the list
local function CheckWhitelist()
    local ok, result = pcall(function()
        return httpRequest({
            Url     = buildUrl("/validate-user"),
            Method  = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body    = HttpService:JSONEncode({ 
                roblox_user = plr.Name,
                hwid        = GetHWID()
            })
        })
    end)
    if not ok or not result then
        return { valid = false, whitelisted = false, need_key = true }
    end
    local ok2, decoded = pcall(HttpService.JSONDecode, HttpService, result.Body)
    if not ok2 then
        return { valid = false, whitelisted = false, need_key = true }
    end
    return decoded
end

-- Round 2: sends username + key -- only called if not whitelisted
local function ValidateKey(key)
    local ok, result = pcall(function()
        return httpRequest({
            Url     = buildUrl("/validate-user"),
            Method  = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body    = HttpService:JSONEncode({ 
                roblox_user = plr.Name, 
                key         = key,
                hwid        = GetHWID()
            })
        })
    end)
    if not ok or not result then
        warn("[Onyx] HTTP request failed: " .. tostring(result))
        return { valid = false, message = "Could not reach key server." }
    end
    local ok2, decoded = pcall(HttpService.JSONDecode, HttpService, result.Body)
    if not ok2 then
        warn("[Onyx] Bad server response: " .. tostring(result.Body))
        return { valid = false, message = "Invalid response from key server." }
    end
    return decoded
end

local function SaveKey(key, expiresAt)
    local data = key .. "|" .. tostring(expiresAt or 0)
    pcall(writefile, KEY_FILE, data)
end

local function LoadSavedKey()
    local ok, data = pcall(readfile, KEY_FILE)
    if not ok or not data or data == "" then return nil end
    local key, expiresStr = data:match("^(.+)|(%d+)$")
    if not key then return nil end
    local expiresAt = tonumber(expiresStr)
    if expiresAt ~= 0 and os.time() >= expiresAt then
        pcall(delfile, KEY_FILE)
        return nil
    end
    return key
end

local function ClearSavedKey()
    pcall(delfile, KEY_FILE)
end


-- =====================================================
-- LOAD MAIN SCRIPT
local function LaunchMainScript()
    local ok, result = pcall(function()
        return httpRequest({
            Url    = MAIN_SCRIPT_URL,
            Method = "GET",
        })
    end)

    if not ok or not result or not result.Body or result.Body == "" then
        warn("[Onyx] Failed to fetch main script from: " .. MAIN_SCRIPT_URL)
        return
    end

    local fn, err = loadstring(result.Body)
    if not fn then
        warn("[Onyx] Failed to compile main script: " .. tostring(err))
        return
    end

    local runOk, runErr = pcall(fn)
    if not runOk then
        warn("[Onyx] Main script errored: " .. tostring(runErr))
    end
end

-- =====================================================
-- AUTH GUI
-- =====================================================
local WIN_W  = 340
local WIN_H  = 252
local REST_Y = 10

local AuthGui = Instance.new("ScreenGui")
AuthGui.Name            = "OnyxAuth"
AuthGui.Parent          = game.CoreGui
AuthGui.ZIndexBehavior  = Enum.ZIndexBehavior.Sibling
AuthGui.ResetOnSpawn    = false
AuthGui.DisplayOrder    = 999

local AuthWin = Instance.new("Frame", AuthGui)
AuthWin.Name                 = "AuthWin"
AuthWin.AnchorPoint          = Vector2.new(0.5, 0)
AuthWin.BackgroundColor3     = Color3.fromRGB(9, 9, 18)
AuthWin.BackgroundTransparency = 0.06
AuthWin.BorderSizePixel      = 0
AuthWin.Position             = UDim2.new(0.5, 0, 0, -(WIN_H + 30))
AuthWin.Size                 = UDim2.new(0, WIN_W, 0, WIN_H)
do
Instance.new("UICorner", AuthWin).CornerRadius = UDim.new(0, 14)
local s = Instance.new("UIStroke", AuthWin)
s.Color = Color3.fromRGB(255,255,255); s.Transparency = 0.82; s.Thickness = 1.2
local ov = Instance.new("Frame", AuthWin)
ov.BackgroundColor3 = Color3.fromRGB(185,195,255); ov.BackgroundTransparency = 0.96
ov.BorderSizePixel = 0; ov.Size = UDim2.new(1,0,1,0)
Instance.new("UICorner", ov).CornerRadius = UDim.new(0,14)
local bar = Instance.new("Frame", AuthWin)
bar.BackgroundColor3 = Color3.fromRGB(140,130,255); bar.BorderSizePixel = 0
bar.Size = UDim2.new(1,0,0,3); bar.Position = UDim2.new(0,0,0,0); bar.ZIndex = 4
Instance.new("UICorner", bar).CornerRadius = UDim.new(0,14)
end

local logo = Instance.new("TextLabel", AuthWin)
logo.BackgroundTransparency = 1
logo.Position   = UDim2.new(0,18,0,16)
logo.Size       = UDim2.new(1,-36,0,26)
logo.Font       = Enum.Font.GothamBlack
logo.Text       = "ONYX"
logo.TextColor3 = Color3.fromRGB(255,255,255)
logo.TextSize   = 20
logo.TextXAlignment = Enum.TextXAlignment.Left
logo.ZIndex     = 3

local sub = Instance.new("TextLabel", AuthWin)
sub.BackgroundTransparency = 1
sub.Position   = UDim2.new(0,18,0,42)
sub.Size       = UDim2.new(1,-36,0,14)
sub.Font       = Enum.Font.Gotham
sub.Text       = "Key System  ‚Ä¢  by Biscuit"
sub.TextColor3 = Color3.fromRGB(110,105,160)
sub.TextSize   = 11
sub.TextXAlignment = Enum.TextXAlignment.Left
sub.ZIndex     = 3

local div = Instance.new("Frame", AuthWin)
div.BackgroundColor3 = Color3.fromRGB(255,255,255); div.BackgroundTransparency = 0.88
div.BorderSizePixel = 0; div.Position = UDim2.new(0,18,0,62); div.Size = UDim2.new(1,-36,0,1); div.ZIndex = 3

local instruct = Instance.new("TextLabel", AuthWin)
instruct.BackgroundTransparency = 1
instruct.Position   = UDim2.new(0,18,0,70)
instruct.Size       = UDim2.new(1,-36,0,32)
instruct.Font       = Enum.Font.Gotham
instruct.Text       = "Checking whitelist..."
instruct.TextColor3 = Color3.fromRGB(150,150,185)
instruct.TextSize   = 11
instruct.TextWrapped = true
instruct.TextXAlignment = Enum.TextXAlignment.Left
instruct.ZIndex     = 3

local KEY_FILE = "onyx_key.txt"

-- Key input
local AuthInput = Instance.new("TextBox", AuthWin)
AuthInput.BackgroundColor3       = Color3.fromRGB(18,18,32)
AuthInput.BackgroundTransparency = 0.2
AuthInput.BorderSizePixel        = 0
AuthInput.Position               = UDim2.new(0,18,0,108)
AuthInput.Size                   = UDim2.new(1,-36,0,32)
AuthInput.PlaceholderText        = "Paste your key here..."
AuthInput.PlaceholderColor3      = Color3.fromRGB(80,75,120)
AuthInput.Text                   = ""
AuthInput.Visible                = false  -- hidden until whitelist check fails
AuthInput.TextColor3             = Color3.fromRGB(220,220,240)
AuthInput.TextSize               = 13
AuthInput.ClearTextOnFocus       = false
AuthInput.ZIndex                 = 3
do
Instance.new("UICorner", AuthInput).CornerRadius = UDim.new(0,8)
local s = Instance.new("UIStroke", AuthInput)
s.Color = Color3.fromRGB(140,130,255); s.Transparency = 0.55; s.Thickness = 1
local p = Instance.new("UIPadding", AuthInput); p.PaddingLeft = UDim.new(0,12)
end

-- Status label
local AuthStatus = Instance.new("TextLabel", AuthWin)
AuthStatus.BackgroundTransparency = 1
AuthStatus.Position     = UDim2.new(0,18,0,140)
AuthStatus.Size         = UDim2.new(1,-36,0,16)
AuthStatus.Font         = Enum.Font.GothamBold
AuthStatus.Text         = ""
AuthStatus.TextColor3   = Color3.fromRGB(200,200,220)
AuthStatus.TextSize     = 11
AuthStatus.TextXAlignment = Enum.TextXAlignment.Center
AuthStatus.ZIndex       = 3

-- Auth button
local AuthBtn = Instance.new("TextButton", AuthWin)
AuthBtn.BackgroundColor3       = Color3.fromRGB(140,130,255)
AuthBtn.BackgroundTransparency = 0.08
AuthBtn.BorderSizePixel        = 0
AuthBtn.Position               = UDim2.new(0,18,0,164)
AuthBtn.Size                   = UDim2.new(1,-36,0,38)
AuthBtn.Font                   = Enum.Font.GothamBold
AuthBtn.Text                   = "Checking..."
AuthBtn.Active                 = false  -- disabled until whitelist check completes
AuthBtn.TextColor3             = Color3.fromRGB(255,255,255)
AuthBtn.TextSize               = 14
AuthBtn.ZIndex                 = 3
AuthBtn.AutoButtonColor        = false
Instance.new("UICorner", AuthBtn).CornerRadius = UDim.new(0,10)
AuthBtn.MouseEnter:Connect(function()
TweenService:Create(AuthBtn, TweenInfo.new(0.15), { BackgroundTransparency = 0 }):Play()
end)
AuthBtn.MouseLeave:Connect(function()
TweenService:Create(AuthBtn, TweenInfo.new(0.15), { BackgroundTransparency = 0.08 }):Play()
end)

-- Bottom hint
local hint = Instance.new("TextLabel", AuthWin)
hint.BackgroundTransparency = 1
hint.Position     = UDim2.new(0,18,0,210)
hint.Size         = UDim2.new(1,-36,0,36)
hint.Font         = Enum.Font.Gotham
hint.Text         = "üîó Complete the Linkvertise link in Discord ‚Üí get your key ‚Üí paste it above\n‚ôæÔ∏è  Whitelisted? You will be let in automatically -- no key needed."
hint.TextColor3   = Color3.fromRGB(80,80,110)
hint.TextSize     = 10
hint.TextWrapped  = true
hint.TextXAlignment = Enum.TextXAlignment.Center
hint.ZIndex       = 3

-- =====================================================
-- SLIDE-IN ANIMATION
-- =====================================================
local REST_POS = UDim2.new(0.5, 0, 0, REST_Y)
task.spawn(function()
task.wait(0.05)
TweenService:Create(
AuthWin,
TweenInfo.new(0.65, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
{ Position = REST_POS }
):Play()
end)

-- =====================================================
-- AUTH LOGIC
-- =====================================================

-- =====================================================
-- AUTH LOGIC
-- =====================================================
local authChecking = false

local function SetStatus(text, color)
AuthStatus.Text       = text
AuthStatus.TextColor3 = color or Color3.fromRGB(200, 200, 220)
end

local function FlashDenied(reason)
SetStatus(reason, Color3.fromRGB(255, 80, 80))
local function pos(ox)
return UDim2.new(REST_POS.X.Scale, REST_POS.X.Offset + ox, REST_POS.Y.Scale, REST_POS.Y.Offset)
end
TweenService:Create(AuthWin, TweenInfo.new(0.05), { Position = pos(9) }):Play()  task.wait(0.05)
TweenService:Create(AuthWin, TweenInfo.new(0.05), { Position = pos(-9) }):Play() task.wait(0.05)
TweenService:Create(AuthWin, TweenInfo.new(0.05), { Position = pos(6) }):Play()  task.wait(0.05)
TweenService:Create(AuthWin, TweenInfo.new(0.05), { Position = REST_POS }):Play()
local stroke = AuthInput:FindFirstChildOfClass("UIStroke")
if stroke then
stroke.Color = Color3.fromRGB(255, 60, 60)
task.wait(1)
if stroke and stroke.Parent then stroke.Color = Color3.fromRGB(140, 130, 255) end
end
end

-- For whitelist: no key to save. For temp keys: save key + expiry for auto-login next time.
local function GrantAccess(keyType, key, expiresAt)
    if keyType ~= "whitelist" and key then
        SaveKey(key, expiresAt)
    end
    
    -- Send execution log to bot
    task.spawn(function()
        SendExecutionLog(keyType)
    end)

    SetStatus(
        keyType == "whitelist" and "‚úì Whitelisted -- Welcome!" or "‚úì Key Valid -- Loading...",
        Color3.fromRGB(80, 255, 140)
    )
AuthBtn.Text             = "‚úì Authenticated"
AuthBtn.BackgroundColor3 = Color3.fromRGB(50, 185, 90)
TweenService:Create(AuthWin,
TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In),
{ Position = UDim2.new(0.5, 0, 0, -(WIN_H + 30)) }
):Play()
task.wait(0.52)
AuthGui:Destroy()
-- Launch directly here -- the main thread repeat loop cannot be relied on
-- because task.spawn coroutines don't resume while the main thread is spinning
LaunchMainScript()
end

-- Step 2: only runs if not whitelisted
local function TryAuthenticate(key)
if authChecking or not AuthBtn.Active then return end
key = key or AuthInput.Text:match("^%s*(.-)%s*$")
if key == "" then FlashDenied("Please enter a key.") return end

    authChecking = true
    AuthBtn.Text             = "Checking..."
    AuthBtn.BackgroundColor3 = Color3.fromRGB(90, 85, 140)
    SetStatus("Contacting key server...", Color3.fromRGB(170, 165, 255))

    task.spawn(function()
        local result = ValidateKey(key)
        if result.valid then
            GrantAccess(result.type, key, result.expires_at)
        else
            ClearSavedKey()
            authChecking = false
            AuthBtn.Text             = "Authenticate"
            AuthBtn.BackgroundColor3 = Color3.fromRGB(140, 130, 255)
            if result.type == "expired" then
                FlashDenied("‚úó DENIED -- Key Expired")
            elseif result.message and result.message:lower():find("blacklisted") then
                FlashDenied("‚úó DENIED -- Device Blacklisted")
            elseif result.message and result.message:find("bound") then
                FlashDenied("‚úó DENIED -- Wrong Username for Key")
            else
                FlashDenied("‚úó DENIED -- Invalid Key")
            end
        end
    end)
end

AuthBtn.MouseButton1Click:Connect(function() TryAuthenticate() end)
AuthInput.FocusLost:Connect(function(enter) if enter then TryAuthenticate() end end)

-- =====================================================
-- STEP 1: WHITELIST CHECK ON LOAD (silent, username-only)
-- Runs immediately after slide-in. If whitelisted ‚Üí straight in, no key needed.
-- If not ‚Üí show key input and enable button.
-- =====================================================
task.spawn(function()
    task.wait(0.7) -- let slide-in finish

    -- Step 1: whitelist check by username
    SetStatus("Checking whitelist...", Color3.fromRGB(170, 165, 255))
    local wl = CheckWhitelist()

    if wl.valid and wl.whitelisted then
        -- Whitelisted -- straight in, no key ever shown
        GrantAccess("whitelist", nil, nil)
        return
    elseif wl.message and wl.message:lower():find("blacklisted") then
        -- Blacklisted -- stop everything
        FlashDenied("‚úó DENIED -- Device Blacklisted")
        AuthBtn.Text = "BLACKLISTED"
        AuthBtn.BackgroundColor3 = Color3.fromRGB(150, 40, 40)
        return
    end

    -- Step 2: not whitelisted -- check for a saved temp key
    local savedKey = LoadSavedKey()

    if savedKey then
        -- Silently try saved key -- no need to show the UI first
        SetStatus("Checking saved key...", Color3.fromRGB(170, 165, 255))
        AuthInput.Text = savedKey
        AuthInput.Visible = true
        AuthBtn.Active = true
        TryAuthenticate(savedKey)
    else
        -- No saved key -- show the input UI for manual entry
        instruct.Text = "You are not whitelisted. Paste your key below.\nGet a free key from the Linkvertise link in our Discord."
        AuthInput.Visible = true
        AuthBtn.Text  = "Authenticate"
        AuthBtn.Active = true
        SetStatus("", nil)
    end
end)

-- =====================================================
-- WAIT FOR AUTH THEN LAUNCH MAIN SCRIPT
-- LaunchMainScript() is called directly inside GrantAccess()
-- after the auth GUI is destroyed, so no blocking loop needed.
-- =====================================================
